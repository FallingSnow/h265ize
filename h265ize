#!/usr/bin/env node

"use strict";

const optional = require('optional');
const yargs = require('yargs');
const _ = require("lodash");
const winston = require("winston");
const mime = require('mime');
const recursive = require('recursive-readdir');
const colors = require('colors');
const moment = require('moment');
require("moment-duration-format");
const filesize = require('filesize');
const fs = require('fs-extra');
const hasbin = require('hasbin');
const math = require('mathjs');
const stripAnsi = require('strip-ansi');
const keypress = require('keypress');

const ffmpegPath = require('ffmpeg-static').path;
const ffprobePath = require('ffprobe-static').path;
const ffmpeg = require('fluent-ffmpeg');
ffmpeg.setFfmpegPath(ffmpegPath);
ffmpeg.setFfprobePath(ffprobePath);

const path = require('path');
const os = require("os");
const readline = require("readline");
const spawn = require('child_process').spawn;

const packageSettings = require(path.resolve(__dirname, 'package.json'));
var userSettings = optional("settings.json") || {};

var h265ize = {},
    state = 'running';

var args;

h265ize.runCli = function() {
    h265ize.parseOptions()
        .then(h265ize.setupLogger)
        .then(h265ize.handleKeypress)
        .then(h265ize.watchSigInt)
        .then(h265ize.preChecks)
        .then(function() {
            return h265ize.createDirectories(args.destination, args.tempDirectory);
        })
        .then(h265ize.processAsPreset)
        .then(function() {
            return h265ize.initStatsFile(path.resolve(process.cwd(), 'h265ize.csv'));
        })
        .then(function() {
            return h265ize.processInput(args._[0] || './');
        })
        .then(h265ize.processVideos)
        .then(h265ize.finished)
        .catch(function(err) {
            logger.error(err);
            cleanUp(true);
        });
};

// Parse Options ---------------------------------------------------------------

h265ize.parseOptions = function() {
    return new Promise(function(resolve, reject) {
        args = yargs
            .usage(colors.underline('Usage:') + ' $0 [options] [file|directory]')
            .options({
                'd': {
                    alias: 'destination',
                    default: userSettings['destination'] || path.resolve(process.cwd(), 'h265'),
                    describe: 'Folder where encoded files are output.',
                    type: 'string',
                    normalize: true,
                    group: 'General:'
                },
                'g': {
                    alias: 'temp-directory',
                    default: userSettings['temp-directory'] || path.resolve(os.tmpdir(), packageSettings.name),
                    describe: 'Folder where files are stored during encoding.',
                    type: 'string',
                    normalize: true,
                    group: 'General:'
                },
                'log-file': {
                    default: userSettings['log-file'] || path.resolve(process.cwd(), 'log.txt'),
                    describe: 'Sets the log file location for all output from h265ize. Enable debug mode via the --debug flag to output to the log file.',
                    type: 'string',
                    normalize: true,
                    group: 'General:'
                },
                'm': {
                    alias: 'preset',
                    default: userSettings['preset'] || 'fast',
                    describe: 'x265 encoder preset.',
                    choices: ['ultrafast', 'superfast', 'veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow', 'placebo'],
                    type: 'string',
                    group: 'General:'
                },
                'as-preset': {
                    default: userSettings['as-preset'] || 'none',
                    describe: 'My personal presets. Descriptions of each preset\'s use and function can be found on the github page.',
                    choices: ['basic', 'anime', 'testing-ssim', 'none'],
                    type: 'string',
                    group: 'Advanced:'
                },
                'n': {
                    alias: 'native-language',
                    default: userSettings['native-language'] || '',
                    describe: 'The native language used to select default audio and subtitles. You may use 3 letter or 2 letter ISO 639-2 Alpha-3/Alpha-2 codes or the full language name. Examples: [eng|en|English|jpn|ja|Japanese]',
                    type: 'string',
                    group: 'General:'
                },
                'f': {
                    alias: 'output-format',
                    default: userSettings['output-format'] || 'mkv',
                    describe: 'Output container format.',
                    choices: ['mkv', 'mp4', 'm4v'],
                    type: 'string',
                    group: 'General:'
                },
                'x': {
                    alias: 'extra-options',
                    default: userSettings['extra-options'] || '',
                    describe: 'Extra x265 options. Options can be found on the x265 options page.',
                    type: 'string',
                    group: 'Advanced:'
                },
                'q': {
                    alias: 'quality',
                    default: userSettings['quality'] || 19,
                    describe: 'Sets the qp quality target',
                    type: 'number',
                    group: 'General:'
                },
                'video-bitrate': {
                    default: userSettings['video-bitrate'] || 0,
                    describe: 'Sets the video bitrate, set to 0 to use qp rate control instead of a target bitrate.',
                    type: 'number',
                    group: 'Advanced:'
                },
                'l': {
                    alias: 'preview-length',
                    default: userSettings['preview-length'] || 30000,
                    describe: 'Milliseconds to encode in preview mode. Max is half the length of input video.',
                    type: 'number',
                    group: 'Advanced:'
                },
                'time-drift-limit': {
                    default: userSettings['time-drift-limit'] || 200,
                    describe: 'Milliseconds the finished encode is allowed to differ from the original\'s length.',
                    type: 'number',
                    group: 'Advanced:'
                },
                // 'depth': {
                //     default: 2,
                //     describe: 'How deep the search for video files should go in subdirectories.',
                //     type: 'number',
                //     group: 'Advanced:'
                // },
                'accurate-timestamps': {
                    default: userSettings['accurate-timestamps'] || false,
                    describe: 'Become blu-ray complient and reduce the max keyInt to the average frame rate.',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                'he-audio': {
                    default: userSettings['he-audio'] || false,
                    describe: 'Re-encode audio to opus at 40kbps/channel.',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                'force-he-audio': {
                    default: userSettings['force-he-audio'] || false,
                    describe: 'Convert all audio to HE format, including lossless formats.',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                'downmix-he-audio': {
                    default: userSettings['downmix-he-audio'] || false,
                    describe: 'Downmix he-audio opus to Dolby Pro Logic II at 96kb/s. Enables he-audio.',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                'auto-audio-titles': {
                    default: userSettings['auto-audio-titles'] || true,
                    describe: 'Determine and add audio stream title metadata for audio streams without pre-existing title metadata. Use --no-auto-audio-titles to disable.',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                'o': {
                    alias: 'override',
                    default: userSettings['override'] || false,
                    describe: 'Enable override mode. Allows conversion of videos that are already encoded by the hevc codec.',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                'p': {
                    alias: 'preview',
                    default: userSettings['preview'] || false,
                    describe: 'Only encode a preview of the video starting at middle of video. See -l/--preview-length for more info.',
                    type: 'boolean',
                    group: 'General:'
                },
                'multi-pass': {
                    default: userSettings['mutli-pass'] || 0,
                    describe: 'Enable multiple passes by the encoder. Must be greater 1.',
                    type: 'number',
                    group: 'Advanced:'
                },
                'disable-upconvert': {
                    default: userSettings['disable-upconvert'] || false,
                    describe: 'Disable Upconvert. Stop converting Vobsub subs to srt. Only works with mkv\'s.',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                'auto-subtitle-titles': {
                    default: userSettings['auto-subtitle-titles'] || true,
                    describe: 'Determine and add subtitle stream title metadata for subtitle streams without pre-existing title metadata. Use --no-auto-subtitle-titles to disable.',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                'stats': {
                    default: userSettings['stats'] || false,
                    describe: 'Output a stats file containing stats for each video converted.',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                'v': {
                    alias: 'verbose',
                    default: userSettings['verbose'] || false,
                    describe: 'Enables verbose mode. Prints extra information.',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                '10bit': {
                    default: userSettings['10bit'] || false,
                    describe: 'Forces encoding videos in 10bit format (Useful for anime).',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                '12bit': {
                    default: userSettings['12bit'] || false,
                    describe: 'Forces encoding videos in 12bit format (Useful for anime).',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                'screenshots': {
                    default: userSettings['screenshots'] || false,
                    describe: 'Take 6 screenshots at regular intervals throughout the finished encode.',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                'scale': {
                    default: userSettings['scale'] || false,
                    describe: 'Width videos should be scale to. Videos will always maintain original aspect ratio. [Examples: 720, 480]',
                    type: 'number',
                    group: 'Advanced:'
                },
                'debug': {
                    default: userSettings['debug'] || false,
                    describe: 'Enables debug mode. Prints extra debugging information.',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                'delete': {
                    default: userSettings['delete'] || false,
                    describe: 'Delete source after encoding is complete and replaces it with new encode. [DANGER]',
                    type: 'boolean',
                    group: 'Advanced:'
                },
                'help': {
                    describe: 'Displays help page.',
                    group: 'Options:'
                },
                'test': {
                    default: userSettings['test'] || false,
                    describe: 'Puts h265ize in test mode. No files will be encoded.',
                    type: 'boolean',
                    group: 'Options:'
                },
                'version': {
                    describe: 'Displays version information.',
                    group: 'Options:'
                },
            })
            .argv;


        // Show help
        if (args.help) {
            console.log(colors.underline('Package:'), colors.yellow(packageSettings.name), '\t', colors.underline('Version:'), colors.yellow(packageSettings.version));
            console.log(colors.underline('Description:'), packageSettings.description);
            yargs.showHelp();
            process.exit(0);
        }

        // Show version
        if (args.version) {
            console.log(packageSettings.name, packageSettings.version);
            process.exit(0);
        }

        resolve();
    });
};

// Enable Logger ---------------------------------------------------------------

var logLevels = {
    levels: {
        error: 0,
        warn: 1,
        alert: 2,
        info: 3,
        verbose: 4,
        debug: 5
    },
    colors: {
        error: 'red',
        warn: 'yellow',
        alert: 'magenta',
        info: 'white',
        verbose: 'cyan',
        debug: 'grey'
    }
};

var logLevel, lastLineWasCleared, logger;

h265ize.setupLogger = function() {
    return new Promise(function(resolve, reject) {
        logLevel = args.debug ? 'debug' : args.verbose ? 'verbose' : 'info';

        winston.addColors(logLevels.colors);
        lastLineWasCleared = false;
        logger = new(winston.Logger)({
            levels: logLevels.levels,
            transports: [
                new(winston.transports.Console)({
                    level: logLevel,
                    colorize: true,
                    label: packageSettings.name,
                    prettyPrint: true,
                    // handleExceptions: true,
                    // humanReadableUnhandledException: true,
                    // timestamp: function() {
                    //     return Date.now();
                    // },
                    formatter: function(options) {
                        let label = options.level === 'error' ? colors[logLevels.colors['error']]('[' + options.label + ']') : colors.green('[' + options.label + ']');
                        let logLevel = (options.level === 'info' || options.level === 'error') ? '' : colors[logLevels.colors[options.level]]('[' + options.level + ']') + ' ';
                        return label + ': ' + logLevel +
                            (undefined !== options.message ? options.message : '') +
                            (options.meta && Object.keys(options.meta).length ? createListString(options.meta) : '');
                    }
                }),
            ],
            filters: [
                function(level, msg, meta) {
                    if (meta.__divider)
                        msg = msg + '\n' + '-'.repeat(process.stdout.columns);

                    delete meta.__clearLine;
                    delete meta.__divider;
                    return msg;
                }
            ],
            rewriters: [
                function(level, msg, meta) {
                    if (meta.__clearLine && lastLineWasCleared) {
                        readline.moveCursor(process.stdout, -1000, -1);
                        readline.clearLine(process.stdout, 0);
                        lastLineWasCleared = true;
                    }
                    else if (meta.__clearLine) {
                        lastLineWasCleared = true;
                    }
                    else {
                        lastLineWasCleared = false;
                    }

                    return meta;
                }
            ]
        });


        if (args.debug) {
            logger.debug('Log file location:', args.logFile);
            logger.add(winston.transports.File, {
                filename: args.logFile,
                level: logLevel,
                label: packageSettings.name,
                prettyPrint: true,
                json: false,
                timestamp: false,
                formatter: function(options) {
                    let label = '[' + options.label + ']';
                    let logLevel = (options.level === 'info' || options.level === 'error') ? '' : '[' + options.level + ']' + ' ';
                    return stripAnsi(label + ': ' + logLevel +
                        (undefined !== options.message ? options.message : '') +
                        (options.meta && Object.keys(options.meta).length ? createListString(options.meta) : ''));
                }
            });
        }

        resolve();
    });
};

h265ize.preChecks = function() {
    return new Promise(function(resolve, reject) {
        if (!args.videoBitrate && args.multiPass > 1) {
            return reject('You must set a video-bitrate to use multipass.');
        }
        resolve();
    });
};

// Handle Keypresses -----------------------------------------------------------

h265ize.handleKeypress = function() {
    return new Promise(function(resolve, reject) {
        logger.verbose('Handling keypresses...');
        // make `process.stdin` begin emitting "keypress" events 
        keypress(process.stdin);

        // listen for the "keypress" event 
        process.stdin.on('keypress', function(ch, key) {
            if (key && key.name == 'd') {
                logger.info('Debugging', !args['debug'] ? 'enabled.' : 'disabled.');
                args['debug'] = !args['debug'];
                h265ize.setupLogger();
            }
            else if (key && key.ctrl && key.name == 'c') {
                readline.clearLine(process.stdout, 0);
                readline.moveCursor(process.stdout, -1000, 0);
                logger.warn('Caught signal interupt! Attempted to clean up.');
                cleanUp(true);
            }
            else if (key && key.name == 'p') {
                if (temp.commandQueue.length < 1) {
                    return logger.info('No encode running...');
                }

                if (state !== 'paused') {
                    h265ize.pause();
                }
                else {
                    h265ize.resume();
                }
            }
        });

        process.stdin.setRawMode(true);
        process.stdin.resume();
        resolve();
    });
};

h265ize.pause = function() {
    _.each(temp.commandQueue, function(command, i) {
        command.kill('SIGTSTP');
    });
    state = 'paused';
    logger.info('Encoder paused!');
};

h265ize.resume = function() {
    _.each(temp.commandQueue, function(command, i) {
        command.kill('SIGCONT');
    });
    state = 'running';
    logger.info('Encoder resumed!');
};

h265ize.statusUpdate = function(video, status, data) {

};

// Ensure directories exist ----------------------------------------------------

h265ize.createDirectories = function(destination, tempDirectory) {
    return new Promise(function(resolve, reject) {
        // Check destination directory
        fs.ensureDir(destination, function(err) {
            if (err) {
                throw err;
            }
            // Check temp directory
            fs.ensureDir(tempDirectory, function(err) {
                if (err) {
                    throw err;
                }
                resolve();
            });
        });
    });
};

// Watch for unclean shutdowns -------------------------------------------------

var temp = {
    files: [],
    commandQueue: []
};

h265ize.watchSigInt = function() {
    return new Promise(function(resolve, reject) {
        process.on('SIGINT', function() {
            readline.clearLine(process.stdout, 0);
            readline.moveCursor(process.stdout, -1000, 0);
            logger.warn('Caught signal interupt! Attempted to clean up.');
            cleanUp(true);
        });
        process.on('uncaughtException', (err) => {
            logger.error(err);
            cleanUp(true);
        });
        resolve();
    });
};

// Special Features ------------------------------------------------------------



// Set aspreset values -----------------------------------------------------------

var asPresetParams = {};
var x265Options;

h265ize.processAsPreset = function() {
    return new Promise(function(resolve, reject) {
        logger.verbose('Setting as-preset options...');

        switch (args.asPreset) {
            case 'basic':
                asPresetParams['preset'] = 'fast';
                asPresetParams['quality'] = '19';
                break;

            case 'anime':
                asPresetParams['preset'] = 'medium';
                asPresetParams['quality'] = '19';

                x265Options = 'allow-non-conformance:ref=8:bframes=8:rd=6:me=star:b-adapt=2:qg-size=64:rc-lookahead=40:scenecut=45:weightb=1:psy-rd=2.0';

                addx265Options(x265Options);
                break;

            case 'testing-ssim':
                x265Options = 'tune=ssim:ssim:psy-rd=0';

                addx265Options(x265Options);
                break;

            case 'none':
                break;

            default:
                logger.error('Unknown as-preset option', colors.yellow(args.asPreset) + '.');
                process.exit(1);
                break;
        }

        _.each(asPresetParams, function(val, key) {
            ifNotSetByUserSet(key, val);
        });

        resolve();
    });
};

// Get Files -------------------------------------------------------------------

var rejectedVideos = {};

// Setup stats file ------------------------------------------------------------

var statsFile = false;

h265ize.initStatsFile = function(path) {
    return new Promise(function(resolve, reject) {
        if (args.stats)
            loadStatsFile(path).then(function(stream) {
                statsFile = stream;
                resolve();
            }).catch(reject);
        else
            resolve();
    });
};


// Process file/directory ------------------------------------------------------

h265ize.processInput = function(input) {
    return new Promise(function(resolve, reject) {
        let fileDescriptorStats;
        try {
            fileDescriptorStats = fs.lstatSync(input);
        }
        catch (e) {
            if (e.code === 'ENOENT') {
                logger.error('Input', input, 'does not exist.');
                return process.exit(0);
            }
            throw e;
        }

        // Check if input is a file
        if (fileDescriptorStats.isFile()) {
            if (mime.lookup(input).startsWith('video/')) {
                resolve([input]);
            }
            else
                reject('Input file', "\'" + input + "\'", 'is not a recognized file format.');
        }

        // Check if input is a directory
        else if (fileDescriptorStats.isDirectory()) {
            // Get all files in directory
            findVideos(input).then(function(videoPaths) {
                logger.verbose('Folder encoding started at', colors.yellow(moment().format("dddd, MMMM Do YYYY, h:mm:ss A")));
                resolve(videoPaths);
            }).catch(function(err) {
                reject(err);
            });
        }

    });
};


// Process Videos --------------------------------------------------------------

h265ize.processVideos = function(videos) {
    return new Promise(function(resolve, reject) {

        if (videos.length > 0) {
            let video = videos.shift();
            let startTime = moment();

            logger.info('Processing', colors.bold(colors.yellow(path.basename(video))) + "...", {
                __divider: true
            });
            logger.verbose('Encoding started at', colors.yellow(startTime.format("ddd, h:mm A")));

            h265ize.processVideo(video).then(function() {
                let endTime = moment();
                let timeDiffMilliseconds = moment.duration(endTime.diff(startTime));
                logger.verbose('Finished encoding at', colors.yellow(endTime.format("ddd, h:mm A")), '(' + moment.duration(timeDiffMilliseconds).humanize() + ')');
                logger.debug('Finished encoding in', colors.yellow(timeDiffMilliseconds / 1000), 'seconds.');
                h265ize.processVideos(videos).then(resolve, reject);
            }).catch(function(err) {
                logger.warn(err);
                rejectedVideos[video] = err.message;
                h265ize.processVideos(videos).then(resolve, reject);
            });
        }
        else {
            resolve();
        }

    });
};

h265ize.processVideo = function(video) {
    return new Promise(function(resolve, reject) {
        h265ize.statusUpdate(video, 'initalize');
        logger.debug('Path:', video);

        let pathData = path.parse(video);
        pathData.filename = pathData.name + pathData.ext;
        let x265Params = '';
        let command = new ffmpeg({
                logger: logger
            })
            .input(video);

        // Lower priority to 10
        command.renice(10);

        // Set video codec
        command.videoCodec('libx265');

        // Set audio codec
        command.audioCodec('copy');

        // Set subtitle codec
        command.outputOptions('-c:s', 'copy');

        // Maintain aspect ratio
        command.keepDAR();

        let inputCounter = 0;
        let pass = 0;

        let relativeDestinationDirectory = path.relative(path.dirname(args._[0] || process.cwd()), pathData.dir);
        let destinationDirectory = path.resolve(args.destination, relativeDestinationDirectory);
        if (args.delete) {
            destinationDirectory = path.dirname(video);
        }

        let fileName = pathData.name + (args.preview ? '-preview' : '') + '.' + args.outputFormat;
        let fileOutput = path.resolve(destinationDirectory, fileName);
        let tempOutput = path.resolve(args.tempDirectory, pathData.name + '.encoding-in-progress.' + args.outputFormat);
        let originalMetadata;

        // Check if output file already exists
        if (!args.preview) {
            try {
                fs.accessSync(fileOutput, fs.F_OK);
                logger.debug('File', colors.yellow(fileOutput), 'already exists.');
                if (!args.delete)
                    return reject({
                        level: 'warn',
                        message: 'Already encoded. Skipping...'
                    });
            }
            catch (e) {}
        }

        // Get video data
        let getMetadata = function(path) {
            return new Promise(function(resolve, reject) {
                h265ize.statusUpdate(video, 'metadata');
                logger.verbose('Getting video metadata...');
                ffmpeg.ffprobe(path, function(err, metadata) {
                    if (err) {
                        logger.error(err.message);
                        logger.debug('ffprobe error stack:', err.stack);
                        return reject({
                            level: 'error',
                            message: 'FFPROBE_ERROR'
                        });
                    }

                    logger.debug('Container data:', {
                        duration: moment.duration(metadata.format.duration, 'seconds').format('hh:mm:ss', {
                            trim: false,
                            forceLength: true
                        }),
                        size: filesize(metadata.format.size)
                    });
                    if (!_.isNumber(metadata.format.duration)) {
                        logger.alert('Could not retrieve video duration. Computing duration...');
                        new ffmpeg({
                            logger: logger
                        }).input(video).outputFormat('null').output('-').on('end', function(stdout, stderr) {
                            let lines = stderr.split('\n');
                            let lastTime = lines[lines.length - 3];
                            let duration = lastTime.match(new RegExp('time=(([0-9]|\:|\.)+) bitrate'))[1];

                            // Fix bug with momentjs https://github.com/moment/moment/issues/3266
                            if (duration.indexOf('.') <= duration.length - 3) {
                                duration += '000';
                            }

                            let seconds = moment.duration(duration);
                            metadata.format.duration = seconds.format("s", 6);
                            resolve(metadata);
                        }).run();
                    }
                    else
                        resolve(metadata);
                });
            });
        };


        let processStreams = function(metadata) {
            return new Promise(function(resolve, reject) {
                h265ize.statusUpdate(video, 'processstreams');
                logger.verbose('Resolving video streams...');

                let videoStreams = [],
                    audioStreams = [],
                    subtitleStreams = [],
                    otherStreams = [];

                // Dissect each video stream
                _.each(metadata.streams, function(stream) {
                    logger.debug('Working on stream:', stream.index);
                    stream.input = 0;

                    // logger.debug(stream);

                    if (!stream.codec_type) {
                        logger.warn('A codec was not provided for stream ' + stream.index + '. Your ffmpeg is most likely out of date. At least version 2.8.2 is recommended.');
                    }

                    switch (stream.codec_type) {
                        case 'video':
                            if (stream.codec_name === 'hevc' && !args.override)
                                return reject({
                                    level: 'warn',
                                    message: 'Already encoded in h265. Skipping... (use the --override flag to encode hevc videos)'
                                });
                            videoStreams.push(stream);
                            break;
                        case 'audio':
                            audioStreams.push(stream);
                            break;
                        case 'subtitle':
                            subtitleStreams.push(stream);
                            break;
                        default:
                            otherStreams.push(stream);
                            break;
                    }
                });

                // Preview Mode
                if (args.preview) {
                    command.seekInput(metadata.format.duration / 2).duration(args.previewLength / 1000);
                }

                if (args.multiPass > 1) {
                    x265Params += '--pass=1:--stats=' + path.resolve(args.tempDirectory, 'x265stats.log') + ':';
                }

                // Scale video
                if (args.scale)
                    command.size('?x' + args.scale);

                resolve({
                    metadata: metadata,
                    streams: {
                        videoStreams: videoStreams,
                        audioStreams: audioStreams,
                        subtitleStreams: subtitleStreams,
                        otherStreams: otherStreams
                    }
                });
            });
        };

        let upconvert = function(data) {
            return new Promise(function(resolve, reject) {
                if (args.disableUpconvert || args.test)
                    return resolve(data);

                h265ize.statusUpdate(video, 'upconvert');

                logger.verbose('Upconverting...');

                let trackUpconvertProcesses = [];

                // Here you can process all subtitles
                _.each(data.streams.subtitleStreams, function(subtitle, i) {

                    // Detect dvdsub subtitles
                    if (subtitle.codec_name === 'dvdsub') {

                        // Convert dvdsub subtitle to srt
                        trackUpconvertProcesses.push(new Promise(function(resolve, reject) {
                            extractTrack(video, subtitle.index).then(vobsubToSRT).then(function(filePath) {
                                delete data.streams.subtitleStreams[i];
                                command.input(filePath);
                                subtitle.input = ++inputCounter;
                                resolve();
                            }).catch(reject);
                        }));
                    }
                });

                logger.debug('Upconverting', trackUpconvertProcesses.length, 'tracks.');
                // Execute all upconvert processes
                Promise.all(trackUpconvertProcesses).then(function() {
                    resolve(data);
                }).catch(reject);

            });
        };

        let setVideoBitDepth = function(data) {
            return new Promise(function(resolve, reject) {
                h265ize.statusUpdate(video, 'videoBitDepth');
                logger.verbose('Setting video bit depth...');

                // Video streams
                let videoIndex = 0,
                    videoBitDepth = 8;

                if (data.streams.videoStreams.length > 1) {
                    // TODO implement feature
                    logger.alert('More than one video stream detected. Using the video stream with the greatest duration.');
                    videoIndex = 0;
                }
                let videoStream = data.videoStream = data.streams.videoStreams[videoIndex];

                // Check for 12bit or 10bit video
                if (videoStream.pix_fmt.indexOf('12le') > -1 || videoStream.pix_fmt.indexOf('12be') > -1) {
                    videoBitDepth = 12;
                }
                else if (videoStream.pix_fmt.indexOf('10le') > -1 || videoStream.pix_fmt.indexOf('10be') > -1) {
                    videoBitDepth = 10;
                }
                data.videoBitDepth = videoBitDepth;

                // Set video encoding profile
                if (userSetOption('12bit')) {
                    command.outputOptions('-pix_fmt', 'yuv420p12le');
                }
                else if (userSetOption('10bit')) {
                    command.outputOptions('-pix_fmt', 'yuv420p10le');
                }
                else {
                    switch (data.videoBitDepth) {
                        case 16:
                            command.outputOptions('-pix_fmt', 'yuv420p16le');
                            break;
                        case 14:
                            command.outputOptions('-pix_fmt', 'yuv420p14le');
                            break;
                        case 12:
                            command.outputOptions('-pix_fmt', 'yuv420p12le');
                            break;
                        case 10:
                            command.outputOptions('-pix_fmt', 'yuv420p10le');
                            break;
                        default:
                            command.outputOptions('-pix_fmt', 'yuv420p');
                            break;
                    }
                }

                resolve(data);
            });
        };

        let normalizeVolume = function(data) {
            // ffmpeg -i video.mkv -filter_complex "[0:a:0]volumedetect" -filter_complex "[0:a:1]volumedetect" -f null -map 0:a:0 -map 0:a:1 -
        };

        let autoCrop = function(data) {
            return new Promise(function(resolve, reject) {
                h265ize.statusUpdate(video, 'autoCrop');
                logger.verbose('Detecting auto crop...');

                const intervals = 12;
                const interval = data.metadata.format.duration / (intervals + 1);

                function detectCrop(start, fallback) {
                    return new Promise(function(resolve, reject) {
                        const cropRegexp = /crop=(-?[0-9]+):(-?[0-9]+):(-?[0-9]+):(-?[0-9]+)/g;
                        let cropDetectCommand = new ffmpeg(video, {
                                logger: logger
                            }).outputOptions('-map', data.videoStream.input + ':' + data.videoStream.index)
                            .videoFilters("cropdetect=0.094:16:0").frames(2).format('null').output('-');

                        if (fallback) {
                            logger.warn('Initial crop detection failed! Running current crop detection in fallback mode. This is significantly slower.');
                            cropDetectCommand.seekOutput(start);
                        }
                        else {
                            cropDetectCommand.seekInput(start);
                        }

                        let commandIndex, crop = {};

                        if (!args.parallel) {
                            commandIndex = temp.commandQueue.push(cropDetectCommand) - 1;
                            cropDetectCommand.run();
                        }

                        cropDetectCommand
                            .on('start', function(commandLine) {
                                logger.debug('Running Query:', commandLine);
                            })
                            .on('end', function(stdout, stderr) {
                                temp.commandQueue.splice(commandIndex, 1);

                                let match = cropRegexp.exec(stderr);
                                if (match === null) {

                                    if (fallback)
                                        return reject({
                                            level: 'error',
                                            message: 'Could not run crop detection.'
                                        });
                                    else
                                        return detectCrop(start, true).then(resolve, reject);
                                }

                                crop.w = parseInt(match[1]);
                                crop.h = parseInt(match[2]);
                                crop.x = parseInt(match[3]);
                                crop.y = parseInt(match[4]);
                                resolve(crop);
                            })
                            .on('error', function(err, stdout, stderr) {
                                temp.commandQueue.splice(commandIndex, 1);
                                logger.debug(err.stack);

                                if (err.message.startsWith('ffmpeg was killed with signal'))
                                    reject('ENDING');
                                else
                                    reject({
                                        level: 'error',
                                        message: err.message
                                    });
                            });
                    });
                }

                let i = 1,
                    cropDetections = [];

                // This just runs all the ffmpeg crop detections in sync so you
                // dont end up with a million threads running
                function syncHandler(crop) {
                    if (crop)
                        cropDetections.push(crop);
                    if (i <= intervals)
                        detectCrop(interval * i++).then(syncHandler, reject);
                    else
                        cropDetectionComplete(cropDetections);
                }
                syncHandler();



                // TODO: this seems overly complicated and inefficent
                // detections is an array of objects, for example
                // [ { w: '1920', h: '1072', x: '0', y: '4' },
                //   { w: '1920', h: '1072', x: '0', y: '4' } ]
                function cropDetectionComplete(detections) {
                    let width = Number.NEGATIVE_INFINITY,
                        height = Number.NEGATIVE_INFINITY,
                        x = Number.POSITIVE_INFINITY,
                        y = Number.POSITIVE_INFINITY;
                    _.each(detections, function(val, key) {

                        if (val.w > width)
                            width = val.w;
                        if (val.h > height)
                            height = val.h;
                        if (val.x < x)
                            x = val.x;
                        if (val.y < y)
                            y = val.y;
                    });

                    command.videoFilters('crop=' + width + ':' + height + ':' + x + ':' + y);
                    resolve(data);
                }
            });
        };

        let mapStreams = function(data) {
            return new Promise(function(resolve, reject) {
                h265ize.statusUpdate(video, 'mapstreams');
                logger.verbose('Mapping streams...');
                data.defaultAudioIndex = null;
                data.defaultSubtitleIndex = null;

                command.outputOptions('-map', data.videoStream.input + ':' + data.videoStream.index);
                logger.debug('Video stream with index', data.videoStream.index, 'mapped.', {
                    size: data.videoStream.width + 'x' + data.videoStream.height,
                    codec: data.videoStream.codec_long_name,
                    profile: data.videoStream.profile,
                    'bit depth': data.videoBitDepth
                });

                // Handle native language detection and default audio track selection
                _.each(data.streams.audioStreams, function(stream, i) {
                    let normalizedLanguage = normalizeStreamLanguage(stream);
                    if (normalizedLanguage === normalizeLanguage(args['native-language']) && !data.defaultAudioIndex) {
                        data.defaultAudioIndex = stream.index;
                    }
                });

                // Audio streams
                _.each(data.streams.audioStreams, function(stream, i) {

                    let audioTitle = getStreamTitle(stream);
                    let normalizedLanguage = normalizeStreamLanguage(stream);

                    command.outputOptions('-map', stream.input + ':' + stream.index);
                    if (!(audioTitle) && args.autoAudioTitles) {
                        let channelsFormated = stream.channels === 2 ? 'Stereo' : stream.channels % 2 ? (stream.channels - 1) + '.1 Channel' : stream.channels + '.0 Channel';
                        let newTitle = normalizedLanguage + ' ' + stream.codec_name.toUpperCase() + ((stream.profile && stream.profile !== 'unknown') ? (' ' + stream.profile) : '') + ' (' + channelsFormated + ')';
                        logger.alert('Audio does not have a title. Title set to', '"' + newTitle + '".');
                        command.outputOptions('-metadata:s:a:' + stream.index, 'title="' + newTitle + '"');
                    }

                    // Set default audio
                    if (data.defaultAudioIndex && data.defaultAudioIndex === stream.index) {
                        command.outputOptions('-metadata:s:a:' + i, 'DISPOSITION:default=1');
                    }

                    let extraInfo = {
                        title: audioTitle,
                        language: normalizedLanguage,
                        codec: stream.codec_long_name,
                        channels: stream.channels
                    };

                    if (stream.profile)
                        extraInfo.profile = stream.profile;
                    else
                        extraInfo['bit-depth'] = stream.bits_per_raw_sample;

                    logger.debug('Audio stream with index', stream.index, 'mapped.', extraInfo);
                });

                // Subtitle streams
                _.each(data.streams.subtitleStreams, function(stream, i) {

                    // Handle native language
                    let normalizedLanguage = normalizeStreamLanguage(stream);
                    if (normalizedLanguage === normalizeLanguage(args['native-language']) && !data.defaultAudioIndex && !data.defaultSubtitleIndex) {
                        data.defaultSubtitleIndex = stream.index;
                    }


                    command.outputOptions('-map', stream.input + ':' + stream.index);
                    if (!getStreamTitle(stream) && args.autoSubtitleTitles) {
                        logger.alert('Subtitle does not have a title. Title set to', normalizedLanguage + '.');
                        command.outputOptions('-metadata:s:s:' + i, 'title=' + normalizedLanguage);
                    }
                    command.outputOptions('-metadata:s:s:' + i, 'DISPOSITION:default=0');
                    logger.debug('Subtitle stream with index', stream.index, 'mapped.', {
                        title: getStreamTitle(stream),
                        language: normalizedLanguage,
                        codec: stream.codec_long_name
                    });
                });

                // Other streams (Attachments: fonts, pictures, etc.)
                _.each(data.streams.otherStreams, function(stream, i) {
                    command.outputOptions('-map', stream.input + ':' + stream.index);
                    logger.debug('Other stream with index', stream.index, 'mapped.');
                });

                resolve(data);
            });
        };

        // High Efficiency audio
        let mapHEAudio = function(data) {
            return new Promise(function(resolve, reject) {
                logger.verbose('Mapping HE Audio streams...');
                if (!args.heAudio)
                    return resolve(data);

                h265ize.statusUpdate(video, 'heAudio');

                _.each(data.streams.audioStreams, function(stream, i) {
                    if (stream.codec_name !== 'flac' || args.forceHeAudio) {
                        logger.verbose('Audio stream', colors.yellow(getStreamTitle(stream) + ' (index: ' + stream.index + ')'), 'will be encoded to HE Audio.');
                        let bitrate = 80 * stream.channels / 2;
                        command.outputOptions('-c:a:' + i, 'libopus');
                        command.outputOptions('-b:a:' + i, bitrate + 'k');
                        command.outputOptions('-frame_duration', 60);
                        if (args.downmixHeAudio && stream.channels > 3) {
                            // Downmix HE Audio
                            command.audioChannels(2).audioFilters('aresample=matrix_encoding=dplii');
                            stream.channels = 2;
                        }


                        // Handle settings a new title
                        let audioTitle = getStreamTitle(stream);
                        let normalizedLanguage = normalizeStreamLanguage(stream);
                        if (!(audioTitle) && args.autoAudioTitles) {
                            let channelsFormated = stream.channels === 2 ? 'Stereo' : stream.channels % 2 ? (stream.channels - 1) + '.1 Channel' : stream.channels + '.0 Channel';
                            let newTitle = normalizedLanguage + ' OPUS (' + channelsFormated + ')';
                            logger.alert('Audio does not have a title. Title set to', '"' + newTitle + '".');
                            command.outputOptions('-metadata:s:a:' + stream.index, 'title="' + newTitle);
                        }
                    }
                    else {
                        logger.alert('Audio stream', colors.yellow(getStreamTitle(stream) + ' (index: ' + stream.index + ')'), 'won\'t be encoded with HE Audio because it is already in FLAC (lossless) format.');
                    }
                });

                resolve(data);
            });
        };

        let setArguments = function(data) {
            return new Promise(function(resolve, reject) {
                h265ize.statusUpdate(video, 'prepare');
                logger.verbose('Setting ffmpeg settings...');

                // Accurate Timestamps
                if (args.accurateTimestamps)
                    addx265Options('keyint=' + math.eval(data.videoStream['avg_frame_rate']).toFixed(0));

                // Video bitrate target or constant quality?
                if (args.videoBitrate) {
                    command.videoBitrate(args.videoBitrate);
                }
                else {
                    x265Params += 'crf=' + args.quality + ':';
                }

                // H265 preset
                if (args.preset)
                    command.outputOptions('-preset', args.preset);

                // H265 extra options
                if (args.x)
                    x265Params += args.x + ':';

                resolve(data);
            });
        };

        let encodeVideo = function(data) {
            return new Promise(function(resolve, reject) {
                h265ize.statusUpdate(video, 'encoding');
                logger.verbose('Encoding video...');
                pass++;
                let startTime = moment();

                if (args.test)
                    return reject({
                        level: 'debug',
                        message: 'Test mode! Skipping...'
                    });

                // Make output directory
                if (!args.delete)
                    fs.ensureDir(destinationDirectory, function(err) {
                        if (err) {
                            logger.warn(video, 'was unable to be encoded. The following error was given:');
                            logger.warn(err);
                        }
                    });

                let commandIndex;
                let frameRate = math.eval(data.videoStream.avg_frame_rate);

                command.outputOptions('-x265-params', x265Params);

                if (!args.parallel) {
                    commandIndex = temp.commandQueue.push(command) - 1;
                    command.save(tempOutput);
                }

                command
                    .on('progress', function(progress) {
                        let elapsed = moment.duration(moment().diff(startTime), 'milliseconds');
                        let processed = momentizeTimemark(progress.timemark);
                        let precent = progress.percent ? progress.percent.toFixed(1) : ((processed.asMilliseconds() / 1000 / data.metadata.format.duration) * 100).toFixed(1);
                        let estimatedFileSize = precent > 10 ? filesize(fs.statSync(tempOutput).size / precent * 100) : '';
                        data.elapsedFormated = elapsed.format('hh:mm:ss', {
                            trim: false,
                            forceLength: true
                        });

                        // let speed = 'x' + getSpeedRatio(progress.timemark, elapsed);
                        let speed = (progress.currentFps / frameRate).toFixed(3);
                        let eta = moment.duration((100 - precent) / 100 * data.metadata.format.duration * (1 / speed), 'seconds').format('hh:mm:ss', {
                            trim: false,
                            forceLength: true
                        });

                        logger.info(colors.bgMagenta.white('[ffmpeg]'), 'Processing:', progress.currentFps + 'fps', precent + '%',
                            '[' + progress.timemark + ']', '|', colors.yellow(data.elapsedFormated), '[x' + speed + ']', colors.blue(eta), colors.blue(estimatedFileSize), {
                                __clearLine: true
                            });

                        h265ize.statusUpdate(video, 'encoding', {
                            fps: progress.currentFps,
                            progress: precent,
                            processed: processed,
                            elapsed: data.elapsedFormated,
                            eta: eta,
                            speed: speed
                        });
                    })
                    .on('start', function(commandLine) {
                        temp.files.push(tempOutput);
                        logger.debug('Running Query:', commandLine);
                    })
                    // .on('stderr', function(stderrLine) {
                    //     logger.info(colors.bgMagenta.white('[ffmpeg]'), stderrLine);
                    // })
                    .on('end', function() {
                        temp.commandQueue.splice(commandIndex, 1);
                        logger.verbose(pathData.filename, 'encoded.');
                        resolve(data);
                    })
                    .on('error', function(err, stdout, stderr) {
                        temp.commandQueue.splice(commandIndex, 1);
                        logger.debug(err.stack);

                        if (err.message.startsWith('ffmpeg was killed with signal'))
                            reject('ENDING');
                        else
                            reject({
                                level: 'error',
                                message: err.message
                            });
                    });

                if (args.parallel) {
                    temp.commandQueue.push(command);
                }
            });
        };

        let multiPass = function(data) {
            return new Promise(function(resolve, reject) {
                if (args.multiPass > 1) {
                    if (pass < args.multiPass) {
                        let newInput = tempOutput + '-pass' + pass;
                        x265Params = '';
                        command = new ffmpeg(newInput, {
                                logger: logger
                            })
                            .outputOptions('-map', 0)
                            .outputOptions('-c', 'copy')
                            .outputOptions('-c:v', 'libx265');

                        if (args.multiPass > 1) {
                            if (args.multiPass === pass + 1) {
                                x265Params += '--pass=2:--stats=' + path.resolve(args.tempDirectory, 'x265stats.log') + ':';
                            }
                            else {
                                x265Params += '--pass=3:--stats=' + path.resolve(args.tempDirectory, 'x265stats.log') + ':';
                            }
                        }

                        return fs.move(tempOutput, newInput, {
                            clobber: true
                        }, function(err) {
                            if (err) {

                                logger.error(err.message);
                                logger.debug(err.stack);

                                return reject({
                                    level: 'warn',
                                    message: 'Error moving file ' + colors.yellow(tempOutput) + ' to ' + colors.yellow(newInput) + '.'
                                });
                            }

                            logger.verbose('Running pass', pass + 1 + '.');
                            return setVideoBitDepth(data).then(setArguments).then(encodeVideo).then(multiPass).then(resolve, reject);
                        });
                    }
                }
                resolve(data);
            });
        };

        let verifyEncode = function(data) {
            return new Promise(function(resolve, reject) {
                logger.verbose('Verifying encoded video...');

                getMetadata(tempOutput).then(function(metadata) {
                    logger.debug('Original Duration:', originalMetadata.format.duration + '(s)\t', 'New Duration:', metadata.format.duration + '(s)');
                    let timeDiff = (originalMetadata.format.duration - metadata.format.duration) * 1000;
                    if (timeDiff > args['time-diff-limit'] && !args.preview) {
                        logger.warn('New encode is', moment.duration(timeDiff).format(), 'longer than the original. The max is', args['time-diff-limit'] + '.');
                        fs.unlinkSync(tempOutput);
                        return reject({
                            level: 'error',
                            message: 'Processed encode did not meet max time slippage requirements.'
                        });
                    }
                    else {
                        data.ratio = (metadata.format.size / originalMetadata.format.size * 100).toFixed(2);
                        data.original = originalMetadata;
                        data.new = metadata;

                        if (args.stats)
                            appendToStatsFile([moment().format('MMMM Do YYYY H:mm:ss a'), pathData.filename, filesize(originalMetadata.format.size), filesize(metadata.format.size), data.ratio + '%', data.elapsedFormated]);

                        resolve(data);
                    }
                });
            });
        };


        let takeScreenshots = function(data) {
            return new Promise(function(resolve, reject) {
                if (!args.screenshots)
                    return resolve(data);
                h265ize.statusUpdate(video, 'screenshots');

                logger.verbose('Taking screenshots...');

                let command = new ffmpeg(tempOutput);
                let commandIndex = temp.commandQueue.push(command);

                command
                    .on('filenames', function(filenames) {
                        if (filenames.length < 6)
                            logger.alert('Only generating', colors.yellow(filenames.length), 'screenshots.');
                    })
                    .on('end', function() {
                        temp.commandQueue.splice(commandIndex, 1);
                        resolve(data);
                    });

                command.screenshots({
                    filename: '%f-%i.png',
                    folder: destinationDirectory,
                    count: 6
                });

            });
        };

        // This is where the actual processing happens

        getMetadata(video)

        // Store original metadata
        .then(function(metadata) {
            return new Promise(function(resolve, reject) {
                originalMetadata = metadata;
                resolve(metadata);
            });
        })

        // Discover video streams to be upconverted and mapped
        .then(processStreams)

        // Upconvert streams
        .then(upconvert)

        // set video bit depth (8bit, 10bit, 12bit, etc.)
        .then(setVideoBitDepth)
            .then(autoCrop)
            .then(mapStreams)
            .then(mapHEAudio)
            .then(setArguments)
            .then(encodeVideo)

        // Check if video needs multiple passes
        .then(multiPass)
            .then(verifyEncode)
            .then(takeScreenshots)
            .then(function(data) {
                logger.info('Processing', colors.bold(colors.yellow(pathData.name + '.' + args.outputFormat)), 'complete.');
                logger.info('Original:', colors.yellow(filesize(data.original.format.size)), '\t', 'New:', colors.yellow(filesize(data.new.format.size)), '\t', 'Precentage:', colors.yellow(data.ratio + '%'));

                if (args.delete)
                    fs.removeSync(video);
                if (args.preview)
                    fs.removeSync(fileOutput);
                logger.verbose('Moving file to final destination. Wait for transfer confirmation message!');
                logger.debug('Output path:', fileOutput);
                fs.move(tempOutput, fileOutput, function(err) {
                    if (err)
                        throw err;

                    logger.verbose(pathData.name + '.' + args.outputFormat, 'transfered successfully.');
                    while (temp.files.indexOf(tempOutput) > -1)
                        temp.files.splice(temp.files.indexOf(tempOutput), 1);

                    h265ize.statusUpdate(video, 'finished');
                    resolve();
                });
            })
            .catch(function(err) {

                h265ize.statusUpdate(video, 'error', err.message);
                rejectedVideos[video] = err.message;
                if (err === 'ENDING') {
                    cleanUp(true);
                }
                else {
                    logger[err.level](err.message);
                    resolve();
                }
            });
    });
};

h265ize.finished = function() {

    logger.info('Folder encoding finished at', colors.yellow(moment().format("dddd, MMMM Do YYYY, h:mm:ss A")), {
        __divider: true
    });
    if (_.keys(rejectedVideos).length)
        logger.alert('The following videos', colors.yellow('(' + _.keys(rejectedVideos).length + ')'), 'were not encoded:', rejectedVideos);

    cleanUp(true);
};


if (!module.parent) {
    h265ize.runCli();
}
else {
    module.exports = h265ize;
}

// Helper Functions ------------------------------------------------------------

String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
};

function dedupeX265ParamsOption(options) {
    let firstIndex = options.indexOf('-x265-params');
    for (let i = firstIndex + 1; i < options.length; i++) {
        if (options[i] === '-x265-params') {
            options[firstIndex + 1] += ':' + options[i + 1];
            options.splice(i, 2);
        }
    }

    return;
}

function momentizeTimemark(timemark) {

    let hours = parseInt(timemark.substring(0, timemark.indexOf(':')), 10);
    let minutes = parseInt(timemark.substring(timemark.indexOf(':') + 1, timemark.lastIndexOf(':')), 10);
    let seconds = parseFloat(timemark.substr(timemark.lastIndexOf(':') + 1));

    return moment.duration().add(hours, 'h').add(minutes, 'm').add(seconds, 's');
}

function userSetOption(option) {
    let formattedOption;
    if (option.length > 1) {
        formattedOption = '--' + option;
    }
    else {
        formattedOption = '-' + option;
    }

    if (process.argv.indexOf(formattedOption) > -1)
        return true;

    // Handle aliases for same option
    for (let aliasIndex in yargs.choices().parsed.aliases[option]) {
        let alias = yargs.choices().parsed.aliases[option][aliasIndex];
        let formattedAlias;
        if (alias.length > 1) {
            formattedAlias = '--' + alias;
        }
        else {
            formattedAlias = '-' + alias;
        }

        if (process.argv.indexOf(formattedAlias) > -1) {
            return true;
        }
    }

    return false;
}

function ifNotSetByUserSet(option, value) {

    if (userSetOption(option))
        return;

    args[option] = value;

    // Handle aliases for same option
    for (let aliasIndex in yargs.choices().parsed.aliases[option]) {
        let alias = yargs.choices().parsed.aliases[option][aliasIndex];
        args[alias] = value;
    }
}

function createListString(files) {
    if (Array.isArray(files))
        return '\n\t- ' + files.join('\n\t- ');

    let array = [];
    _.each(files, function(value, key) {
        array.push(colors.yellow(key) + ': ' + value);
    });
    return '\n\t- ' + array.join('\n\t- ');
}

function cleanUp(ending) {
    logger.verbose('Cleaning up temp files...');
    if (!args.debug) {
        _.each(temp.files, function(file) {
            try {
                fs.unlinkSync(file);
            }
            catch (err) {
                if (err.code !== 'ENOENT')
                    logger.error(err);
            }
        });
    }
    else {
        if (temp.files.length)
            logger.alert('The following temporary files were not deleted because you are in debug mode:', temp.files);
    }

    if (ending) {
        if (statsFile)
            statsFile.end();

        if (temp.commandQueue.length)
            _.each(temp.commandQueue, function(command, i) {
                command.kill();
            });
        temp.commandQueue.length = 0;

        logger.info('Process exited.');
        process.exit(0);
    }
}

function extractTrack(videoPath, trackIndex) {
    return new Promise(function(resolve, reject) {
        if (!hasbin.sync('mkvextract')) {
            logger.warn('Upconvert skipped. mkvextract binary could not be located. Make sure you have it installed.');
            return reject({
                level: 'warn',
                message: 'MKVEXTRACT_NOT_INSTALLED'
            });
        }
        logger.debug('Extracting track', trackIndex, 'from', base);

        let base = path.basename(videoPath);
        let output = path.resolve(args.tempDirectory, base + '-track' + trackIndex);

        spawn('mkvextract', ['track', trackIndex + ':' + output])
            .on('close', (code) => {
                if (code !== 0) {
                    logger.warn('mkvextract exited with error code:', code);
                    logger.warn('Skipping video', path.filename + '.');
                    return reject({
                        level: 'error',
                        message: 'MKVEXTRACT_ERROR'
                    });
                }
                resolve(output);
            });

    });
}

function addx265Options(options) {
    args['x'] = options + (args['x'] ? (':' + args['x']) : '');
    args['extra-options'] = options + (args['extra-options'] ? (':' + args['extra-options']) : '');
}


function vobsubToSRT(filePath) {
    return new Promise(function(resolve, reject) {
        if (!hasbin.sync('vobsub2srt')) {
            logger.warn('Upconvert skipped. vobsub2srt binary could not be located. Make sure you have it installed.');
            return reject({
                level: 'warn',
                message: 'VOBSUB2SRT_NOT_INSTALLED'
            });
        }
        logger.debug('Converting', filePath, 'to srt file.');

        spawn('vobsub2srt', [filePath])
            .on('close', (code) => {
                if (code !== 0) {
                    logger.warn('vobsub2srt exited with error code:', code);
                    logger.warn('Skipping video', path.filename + '.');
                    return reject({
                        level: 'error',
                        message: 'VOBSUB2SRT_ERROR'
                    });
                }
                resolve(filePath + '.srt');
            });
    });
}

function getStreamTitle(stream) {
    return stream.title || stream.tags ? stream.tags.title : undefined;
}

function normalizeStreamLanguage(stream) {
    let lang = stream.language || stream.tags ? stream.tags.language : undefined;
    if (typeof lang === 'undefined')
        return 'Unknown';

    switch (lang.length) {
        case 2:
            return alpha2Languages[lang] || "Unknown";
        case 3:
            return alpha3Languages[lang] || "Unknown";
        default:
            return lang.capitalize() || "Unknown";
    }
}

function normalizeLanguage(lang) {
    if (typeof lang === 'undefined')
        return '';

    switch (lang.length) {
        case 2:
            return alpha2Languages[lang] || "Unknown";
        case 3:
            return alpha3Languages[lang] || "Unknown";
        default:
            return lang.capitalize() || "Unknown";
    }
}

function findVideos(path) {
    return new Promise(function(resolve, reject) {
        recursive(path, function(err, files) {

            let videos = [];

            // Handle any errors given while searching input directory
            if (err) {
                logger.debug('Error:', err);
                if (err.code === 'ENOENT')
                    return reject('File or directory ' + colors.yellow(args._[0] || process.cwd()) + ' does not exist.');
                else
                    throw err;
            }


            // Check if each file is a video
            _.each(files, function(file) {
                if (mime.lookup(file).startsWith('video/'))
                    videos.push(file);
            });

            // Files is an array of filename
            logger.debug('Video files found: ', videos);

            resolve(videos);
        });
    });
}

function loadStatsFile(path) {
    return new Promise(function(resolve, reject) {
        fs.access(path, fs.F_OK, function(err) {
            let stream = fs.createWriteStream('h265ize.csv', {
                'flags': 'a'
            });

            if (err) {
                stream.write('Encoded Date,Filename,Original Size,New Size,Precentage,Duration of Encode');
            }

            resolve(stream);
        });
    });
}

function appendToStatsFile(data) {
    _.each(data, function(val, i) {
        if (val.indexOf(',') > -1) {
            data[i] = '"' + val + '"';
        }
    });
    logger.debug('Writing to stats file:', data);
    statsFile.write('\n' + data.join(','));
}

var alpha2Languages = {
    "aa": "Afar",
    "ab": "Abkhazian",
    "ae": "Avestan",
    "af": "Afrikaans",
    "ak": "Akan",
    "am": "Amharic",
    "an": "Aragonese",
    "ar": "Arabic",
    "as": "Assamese",
    "av": "Avaric",
    "ay": "Aymara",
    "az": "Azerbaijani",
    "ba": "Bashkir",
    "be": "Belarusian",
    "bg": "Bulgarian",
    "bh": "Bihari languages",
    "bi": "Bislama",
    "bm": "Bambara",
    "bn": "Bengali",
    "bo": "Tibetan",
    "br": "Breton",
    "bs": "Bosnian",
    "ca": "Catalan; Valencian",
    "ce": "Chechen",
    "ch": "Chamorro",
    "co": "Corsican",
    "cr": "Cree",
    "cs": "Czech",
    "cu": "Church Slavic; Old Slavonic; Church Slavonic; Old Bulgarian; Old Church Slavonic",
    "cv": "Chuvash",
    "cy": "Welsh",
    "da": "Danish",
    "de": "German",
    "dv": "Divehi; Dhivehi; Maldivian",
    "dz": "Dzongkha",
    "ee": "Ewe",
    "el": "Greek: Modern (1453-)",
    "en": "English",
    "eo": "Esperanto",
    "es": "Spanish; Castilian",
    "et": "Estonian",
    "eu": "Basque",
    "fa": "Persian",
    "ff": "Fulah",
    "fi": "Finnish",
    "fj": "Fijian",
    "fo": "Faroese",
    "fr": "French",
    "fy": "Western Frisian",
    "ga": "Irish",
    "gd": "Gaelic; Scottish Gaelic",
    "gl": "Galician",
    "gn": "Guarani",
    "gu": "Gujarati",
    "gv": "Manx",
    "ha": "Hausa",
    "he": "Hebrew",
    "hi": "Hindi",
    "ho": "Hiri Motu",
    "hr": "Croatian",
    "ht": "Haitian; Haitian Creole",
    "hu": "Hungarian",
    "hy": "Armenian",
    "hz": "Herero",
    "ia": "Interlingua (International Auxiliary Language Association)",
    "id": "Indonesian",
    "ie": "Interlingue; Occidental",
    "ig": "Igbo",
    "ii": "Sichuan Yi; Nuosu",
    "ik": "Inupiaq",
    "io": "Ido",
    "is": "Icelandic",
    "it": "Italian",
    "iu": "Inuktitut",
    "ja": "Japanese",
    "jv": "Javanese",
    "ka": "Georgian",
    "kg": "Kongo",
    "ki": "Kikuyu; Gikuyu",
    "kj": "Kuanyama; Kwanyama",
    "kk": "Kazakh",
    "kl": "Kalaallisut; Greenlandic",
    "km": "Central Khmer",
    "kn": "Kannada",
    "ko": "Korean",
    "kr": "Kanuri",
    "ks": "Kashmiri",
    "ku": "Kurdish",
    "kv": "Komi",
    "kw": "Cornish",
    "ky": "Kirghiz; Kyrgyz",
    "la": "Latin",
    "lb": "Luxembourgish; Letzeburgesch",
    "lg": "Ganda",
    "li": "Limburgan; Limburger; Limburgish",
    "ln": "Lingala",
    "lo": "Lao",
    "lt": "Lithuanian",
    "lu": "Luba-Katanga",
    "lv": "Latvian",
    "mg": "Malagasy",
    "mh": "Marshallese",
    "mi": "Maori",
    "mk": "Macedonian",
    "ml": "Malayalam",
    "mn": "Mongolian",
    "mr": "Marathi",
    "ms": "Malay",
    "mt": "Maltese",
    "my": "Burmese",
    "na": "Nauru",
    "nb": "Bokml: Norwegian; Norwegian Bokml",
    "nd": "Ndebele: North; North Ndebele",
    "ne": "Nepali",
    "ng": "Ndonga",
    "nl": "Dutch; Flemish",
    "nn": "Norwegian Nynorsk; Nynorsk: Norwegian",
    "no": "Norwegian",
    "nr": "Ndebele: South; South Ndebele",
    "nv": "Navajo; Navaho",
    "ny": "Chichewa; Chewa; Nyanja",
    "oc": "Occitan (post 1500); Provenal",
    "oj": "Ojibwa",
    "om": "Oromo",
    "or": "Oriya",
    "os": "Ossetian; Ossetic",
    "pa": "Panjabi; Punjabi",
    "pi": "Pali",
    "pl": "Polish",
    "ps": "Pushto; Pashto",
    "pt": "Portuguese",
    "qu": "Quechua",
    "rm": "Romansh",
    "rn": "Rundi",
    "ro": "Romanian; Moldavian; Moldovan",
    "ru": "Russian",
    "rw": "Kinyarwanda",
    "sa": "Sanskrit",
    "sc": "Sardinian",
    "sd": "Sindhi",
    "se": "Northern Sami",
    "sg": "Sango",
    "si": "Sinhala; Sinhalese",
    "sk": "Slovak",
    "sl": "Slovenian",
    "sm": "Samoan",
    "sn": "Shona",
    "so": "Somali",
    "sq": "Albanian",
    "sr": "Serbian",
    "ss": "Swati",
    "st": "Sotho: Southern",
    "su": "Sundanese",
    "sv": "Swedish",
    "sw": "Swahili",
    "ta": "Tamil",
    "te": "Telugu",
    "tg": "Tajik",
    "th": "Thai",
    "ti": "Tigrinya",
    "tk": "Turkmen",
    "tl": "Tagalog",
    "tn": "Tswana",
    "to": "Tonga (Tonga Islands)",
    "tr": "Turkish",
    "ts": "Tsonga",
    "tt": "Tatar",
    "tw": "Twi",
    "ty": "Tahitian",
    "ug": "Uighur; Uyghur",
    "uk": "Ukrainian",
    "ur": "Urdu",
    "uz": "Uzbek",
    "ve": "Venda",
    "vi": "Vietnamese",
    "vo": "Volapk",
    "wa": "Walloon",
    "wo": "Wolof",
    "xh": "Xhosa",
    "yi": "Yiddish",
    "yo": "Yoruba",
    "za": "Zhuang; Chuang",
    "zh": "Chinese",
    "zu": "Zulu",
    "un": "Unknown",
};
var alpha3Languages = {
    "aar": "Afar",
    "abk": "Abkhazian",
    "afr": "Afrikaans",
    "aka": "Akan",
    "alb": "Albanian",
    "amh": "Amharic",
    "ara": "Arabic",
    "arg": "Aragonese",
    "arm": "Armenian",
    "asm": "Assamese",
    "ava": "Avaric",
    "ave": "Avestan",
    "aym": "Aymara",
    "aze": "Azerbaijani",
    "bak": "Bashkir",
    "bam": "Bambara",
    "baq": "Basque",
    "bel": "Belarusian",
    "ben": "Bengali",
    "bih": "Bihari languages",
    "bis": "Bislama",
    "bos": "Bosnian",
    "bre": "Breton",
    "bul": "Bulgarian",
    "bur": "Burmese",
    "cat": "Catalan; Valencian",
    "cha": "Chamorro",
    "che": "Chechen",
    "chi": "Chinese",
    "chu": "Church Slavic; Old Slavonic; Church Slavonic; Old Bulgarian; Old Church Slavonic",
    "chv": "Chuvash",
    "cor": "Cornish",
    "cos": "Corsican",
    "cre": "Cree",
    "cze": "Czech",
    "dan": "Danish",
    "div": "Divehi; Dhivehi; Maldivian",
    "dut": "Dutch; Flemish",
    "dzo": "Dzongkha",
    "eng": "English",
    "epo": "Esperanto",
    "est": "Estonian",
    "ewe": "Ewe",
    "fao": "Faroese",
    "fij": "Fijian",
    "fin": "Finnish",
    "fre": "French",
    "fry": "Western Frisian",
    "ful": "Fulah",
    "geo": "Georgian",
    "ger": "German",
    "gla": "Gaelic; Scottish Gaelic",
    "gle": "Irish",
    "glg": "Galician",
    "glv": "Manx",
    "gre": "Greek, Modern (1453-)",
    "grn": "Guarani",
    "guj": "Gujarati",
    "hat": "Haitian; Haitian Creole",
    "hau": "Hausa",
    "heb": "Hebrew",
    "her": "Herero",
    "hin": "Hindi",
    "hmo": "Hiri Motu",
    "hrv": "Croatian",
    "hun": "Hungarian",
    "ibo": "Igbo",
    "ice": "Icelandic",
    "ido": "Ido",
    "iii": "Sichuan Yi; Nuosu",
    "iku": "Inuktitut",
    "ile": "Interlingue; Occidental",
    "ina": "Interlingua (International Auxiliary Language Association)",
    "ind": "Indonesian",
    "ipk": "Inupiaq",
    "ita": "Italian",
    "jav": "Javanese",
    "jpn": "Japanese",
    "kal": "Kalaallisut; Greenlandic",
    "kan": "Kannada",
    "kas": "Kashmiri",
    "kau": "Kanuri",
    "kaz": "Kazakh",
    "khm": "Central Khmer",
    "kik": "Kikuyu; Gikuyu",
    "kin": "Kinyarwanda",
    "kir": "Kirghiz; Kyrgyz",
    "kom": "Komi",
    "kon": "Kongo",
    "kor": "Korean",
    "kua": "Kuanyama; Kwanyama",
    "kur": "Kurdish",
    "lao": "Lao",
    "lat": "Latin",
    "lav": "Latvian",
    "lim": "Limburgan; Limburger; Limburgish",
    "lin": "Lingala",
    "lit": "Lithuanian",
    "ltz": "Luxembourgish; Letzeburgesch",
    "lub": "Luba-Katanga",
    "lug": "Ganda",
    "mac": "Macedonian",
    "mah": "Marshallese",
    "mal": "Malayalam",
    "mao": "Maori",
    "mar": "Marathi",
    "may": "Malay",
    "mlg": "Malagasy",
    "mlt": "Maltese",
    "mon": "Mongolian",
    "nau": "Nauru",
    "nav": "Navajo; Navaho",
    "nbl": "Ndebele, South; South Ndebele",
    "nde": "Ndebele, North; North Ndebele",
    "ndo": "Ndonga",
    "nep": "Nepali",
    "nno": "Norwegian Nynorsk; Nynorsk, Norwegian",
    "nob": "Bokml, Norwegian; Norwegian Bokml",
    "nor": "Norwegian",
    "nya": "Chichewa; Chewa; Nyanja",
    "oci": "Occitan (post 1500); Provenal",
    "oji": "Ojibwa",
    "ori": "Oriya",
    "orm": "Oromo",
    "oss": "Ossetian; Ossetic",
    "pan": "Panjabi; Punjabi",
    "per": "Persian",
    "pli": "Pali",
    "pol": "Polish",
    "por": "Portuguese",
    "pus": "Pushto; Pashto",
    "que": "Quechua",
    "roh": "Romansh",
    "rum": "Romanian; Moldavian; Moldovan",
    "run": "Rundi",
    "rus": "Russian",
    "sag": "Sango",
    "san": "Sanskrit",
    "sin": "Sinhala; Sinhalese",
    "slo": "Slovak",
    "slv": "Slovenian",
    "sme": "Northern Sami",
    "smo": "Samoan",
    "sna": "Shona",
    "snd": "Sindhi",
    "som": "Somali",
    "sot": "Sotho, Southern",
    "spa": "Spanish; Castilian",
    "srd": "Sardinian",
    "srp": "Serbian",
    "ssw": "Swati",
    "sun": "Sundanese",
    "swa": "Swahili",
    "swe": "Swedish",
    "tah": "Tahitian",
    "tam": "Tamil",
    "tat": "Tatar",
    "tel": "Telugu",
    "tgk": "Tajik",
    "tgl": "Tagalog",
    "tha": "Thai",
    "tib": "Tibetan",
    "tir": "Tigrinya",
    "ton": "Tonga (Tonga Islands)",
    "tsn": "Tswana",
    "tso": "Tsonga",
    "tuk": "Turkmen",
    "tur": "Turkish",
    "twi": "Twi",
    "uig": "Uighur; Uyghur",
    "ukr": "Ukrainian",
    "urd": "Urdu",
    "uzb": "Uzbek",
    "ven": "Venda",
    "vie": "Vietnamese",
    "vol": "Volapk",
    "wel": "Welsh",
    "wln": "Walloon",
    "wol": "Wolof",
    "xho": "Xhosa",
    "yid": "Yiddish",
    "yor": "Yoruba",
    "zha": "Zhuang; Chuang",
    "zul": "Zulu"
};
